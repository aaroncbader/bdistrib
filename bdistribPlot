#!/usr/bin/env python

print "usage: bdistribPlot bdistrib_out.XXX.nc"

import matplotlib as mpl
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
import numpy as np
from scipy.io import netcdf
from scipy.interpolate import interp1d
import sys
import math

if len(sys.argv) != 2:
    print "Error! You must specify 1 argument: the bdistrib_out.XXX.nc file."
    exit(1)


f = netcdf.netcdf_file(sys.argv[1],'r',mmap=False)
nfp = f.variables['nfp'][()]
nu_plasma = f.variables['nu_plasma'][()]
nu_middle = f.variables['nu_middle'][()]
nu_outer = f.variables['nu_outer'][()]
nv_plasma = f.variables['nv_plasma'][()]
nv_middle = f.variables['nv_middle'][()]
nv_outer = f.variables['nv_outer'][()]
nvl_plasma = f.variables['nvl_plasma'][()]
nvl_middle = f.variables['nvl_middle'][()]
nvl_outer = f.variables['nvl_outer'][()]
u_plasma = f.variables['u_plasma'][()]
u_middle = f.variables['u_middle'][()]
u_outer  = f.variables['u_outer'][()]
v_plasma = f.variables['v_plasma'][()]
v_middle = f.variables['v_middle'][()]
v_outer  = f.variables['v_outer'][()]
vl_plasma = f.variables['vl_plasma'][()]
vl_middle = f.variables['vl_middle'][()]
vl_outer = f.variables['vl_outer'][()]
r_plasma  = f.variables['r_plasma'][()]
r_middle  = f.variables['r_middle'][()]
r_outer = f.variables['r_outer'][()]
xm_plasma = f.variables['xm_plasma'][()]
xm_middle = f.variables['xm_middle'][()]
xm_outer  = f.variables['xm_outer'][()]
xn_plasma = f.variables['xn_plasma'][()]
xn_middle = f.variables['xn_middle'][()]
xn_outer  = f.variables['xn_outer'][()]
mnmax_plasma = f.variables['mnmax_plasma'][()]
mnmax_middle = f.variables['mnmax_middle'][()]
mnmax_outer  = f.variables['mnmax_outer'][()]
svd_s_inductance_plasma = f.variables['svd_s_inductance_plasma'][()]
svd_s_inductance_middle = f.variables['svd_s_inductance_middle'][()]
svd_s_transferMatrix = f.variables['svd_s_transferMatrix'][()]
svd_u_transferMatrix_sin = f.variables['svd_u_transferMatrix_sin'][()]
svd_u_transferMatrix_cos = f.variables['svd_u_transferMatrix_cos'][()]
svd_v_transferMatrix_sin = f.variables['svd_v_transferMatrix_sin'][()]
svd_v_transferMatrix_cos = f.variables['svd_v_transferMatrix_cos'][()]
n_pseudoinverse_thresholds = f.variables['n_pseudoinverse_thresholds'][()]
n_singular_vectors_to_save = f.variables['n_singular_vectors_to_save'][()]
pseudoinverse_thresholds = f.variables['pseudoinverse_thresholds'][()]
basis_option = f.variables['basis_option'][()]
if basis_option==3:
    basis_to_Fourier_plasma = f.variables['basis_to_Fourier_plasma'][()]
    basis_to_Fourier_middle = f.variables['basis_to_Fourier_middle'][()]

print "nu_plasma: ",nu_plasma
print "nvl_plasma: ",nvl_plasma
print "r_plasma.shape: ",r_plasma.shape
print "svd_s_transferMatrix.shape: ",svd_s_transferMatrix.shape
print "svd_u_transferMatrix_sin.shape: ",svd_u_transferMatrix_sin.shape

f.close()

#exit(0)

########################################################
# Plot singular values
########################################################

figureNum = 1
fig = plt.figure(figureNum)
fig.patch.set_facecolor('white')

plt.plot(svd_s_inductance_middle,'.m',label='Inductance matrix between middle and outer surfaces')
plt.plot(svd_s_inductance_plasma,'.r',label='Inductance matrix between plasma and outer surfaces')
colors=['k','g','orange','c','brown','gray','darkred','olive','darkviolet','gold','lawngreen']
for i in range(n_pseudoinverse_thresholds):
    plt.plot(svd_s_transferMatrix[i,:],'.',color=colors[i],label='Transfer matrix, thresh='+str(pseudoinverse_thresholds[i]))
plt.legend(fontsize='x-small',loc=3)
plt.title('Singular values')
plt.yscale('log')

########################################################
# For 3D plotting, 'close' the arrays in u and v
########################################################

r_plasma  = np.append(r_plasma,  r_plasma[[0],:,:], axis=0)
r_plasma  = np.append(r_plasma,  r_plasma[:,[0],:], axis=1)
vl_plasma = np.append(vl_plasma,nfp)

r_middle  = np.append(r_middle,  r_middle[[0],:,:], axis=0)
r_middle  = np.append(r_middle,  r_middle[:,[0],:], axis=1)
vl_middle = np.append(vl_middle,nfp)

r_outer = np.append(r_outer, r_outer[[0],:,:], axis=0)
r_outer = np.append(r_outer, r_outer[:,[0],:], axis=1)
vl_outer = np.append(vl_outer,nfp)

########################################################
# Extract cross-sections of the 3 surfaces at several toroidal angles
########################################################

def getCrossSection(rArray, vl_old, v_new):
    x = rArray[:,:,0]
    y = rArray[:,:,1]
    z = rArray[:,:,2]
    R = np.sqrt(x**2 + y**2)

    nu = z.shape[1]
    nv_new = len(v_new)
    R_slice = np.zeros([nv_new,nu])
    Z_slice = np.zeros([nv_new,nu])
    for iu in range(nu):
        interpolator = interp1d(vl_old, R[:,iu])
        R_slice[:,iu] = interpolator(v_new)
        interpolator = interp1d(vl_old, z[:,iu])
        Z_slice[:,iu] = interpolator(v_new)

    return R_slice, Z_slice

v_slices = [0, 0.25, 0.5, 0.75]
R_slice_plasma, Z_slice_plasma = getCrossSection(r_plasma, vl_plasma, v_slices)
R_slice_middle, Z_slice_middle = getCrossSection(r_middle, vl_middle, v_slices)
R_slice_outer, Z_slice_outer = getCrossSection(r_outer, vl_outer, v_slices)

########################################################
# Now make plot of surfaces at given toroidal angle
########################################################

figureNum += 1
fig = plt.figure(figureNum)
fig.patch.set_facecolor('white')

numRows = 2
numCols = 2

Rmin = R_slice_outer.min()
Rmax = R_slice_outer.max()
Zmin = Z_slice_outer.min()
Zmax = Z_slice_outer.max()

for whichPlot in range(4):
    plt.subplot(numRows,numCols,whichPlot+1)
    v = v_slices[whichPlot]
    plt.plot( R_slice_plasma[whichPlot,:],  Z_slice_plasma[whichPlot,:], 'r.-', label='plasma')
    plt.plot( R_slice_middle[whichPlot,:],  Z_slice_middle[whichPlot,:], 'm.-', label='middle')
    plt.plot(R_slice_outer[whichPlot,:], Z_slice_outer[whichPlot,:], 'b.-', label='outer')
    plt.gca().set_aspect('equal',adjustable='box')
    plt.legend(fontsize='x-small')
    plt.title('v='+str(v))
    plt.xlabel('R')
    plt.ylabel('Z')
    plt.xlim([Rmin,Rmax])
    plt.ylim([Zmin,Zmax])

plt.tight_layout()

#plt.show()
#exit(0)

########################################################
# Plot matrices related basis functions to Fourier modes
########################################################

if basis_option == 3:
    figureNum += 1
    fig = plt.figure(figureNum)
    fig.patch.set_facecolor('white')
    numCols = 2
    numRows = 2
    titleFontSize = 12

    plt.subplot(numRows,numCols,1)
    data = np.abs(basis_to_Fourier_plasma.transpose())
    plt.pcolormesh(data)
    plt.gca().invert_yaxis()
    plt.colorbar()
    plt.title('abs(basis_to_Fourier_plasma)',fontsize=titleFontSize)

    plt.subplot(numRows,numCols,2)
    data[data<1e-17] = 1e-17
    plt.pcolormesh(np.log10(data))
    plt.gca().invert_yaxis()
    plt.colorbar()
    plt.title('log_10(abs(basis_to_Fourier_plasma))',fontsize=titleFontSize)

    plt.subplot(numRows,numCols,3)
    data = np.abs(basis_to_Fourier_middle.transpose())
    plt.pcolormesh(data)
    plt.gca().invert_yaxis()
    plt.colorbar()
    plt.title('abs(basis_to_Fourier_middle)',fontsize=titleFontSize)

    plt.subplot(numRows,numCols,4)
    data[data<1e-17] = 1e-17
    plt.pcolormesh(np.log10(data))
    plt.gca().invert_yaxis()
    plt.colorbar()
    plt.title('log_10(abs(basis_to_Fourier_middle))',fontsize=titleFontSize)

    plt.tight_layout()
    

########################################################
# Plot singular vectors on the plasma surface
########################################################

mpl.rc('xtick',labelsize=7)
mpl.rc('ytick',labelsize=7)

numContours = 20

nu_plot = 100
nv_plot = 102
u_plot = np.linspace(0,1,num=nu_plot)
v_plot = np.linspace(0,1,num=nv_plot)
v_plot_2D, u_plot_2D = np.meshgrid(v_plot, u_plot)
v_plot_2D_column = np.reshape(v_plot_2D,[nu_plot*nv_plot],order='F')
u_plot_2D_column = np.reshape(u_plot_2D,[nu_plot*nv_plot],order='F')
FourierToX_sin = np.zeros([nu_plot*nv_plot, mnmax_plasma])
FourierToX_cos = np.zeros([nu_plot*nv_plot, mnmax_plasma])
for imn in range(mnmax_plasma):
    FourierToX_sin[:,imn] = np.sin(2*np.pi*(xm_plasma[imn]*u_plot_2D_column+xn_plasma[imn]*v_plot_2D_column))
    FourierToX_cos[:,imn] = np.cos(2*np.pi*(xm_plasma[imn]*u_plot_2D_column+xn_plasma[imn]*v_plot_2D_column))

for whichThreshold in range(n_pseudoinverse_thresholds):
    figureNum += 1
    fig = plt.figure(figureNum)
    fig.patch.set_facecolor('white')
    numCols = int(np.ceil(np.sqrt(n_singular_vectors_to_save)))
    numRows = int(np.ceil(n_singular_vectors_to_save*1.0/numCols))

    for whichPlot in range(n_singular_vectors_to_save):
        plt.subplot(numRows,numCols,whichPlot+1)
        data = np.reshape(np.dot(FourierToX_sin, svd_u_transferMatrix_sin[whichThreshold,whichPlot,:]) + \
                          np.dot(FourierToX_cos, svd_u_transferMatrix_cos[whichThreshold,whichPlot,:]), [nu_plot,nv_plot],order='F')
        plt.contourf(v_plot, u_plot, data, numContours)
        #plt.colorbar()
        plt.xlabel('v',fontsize='x-small')
        plt.ylabel('u',fontsize='x-small')
        plt.title('Singular vector u '+str(whichPlot+1)+"\ns="+str(svd_s_transferMatrix[whichThreshold,whichPlot]),fontsize='x-small')

    plt.tight_layout()
    ax = fig.add_axes(np.array([0,0,1,1]), frameon=False)
    ax.text(0.5,0.99,"Efficiency-ordered B_n distributions on the plasma surface (threshold="+str(pseudoinverse_thresholds[whichThreshold])+")",horizontalalignment='center',verticalalignment='top',fontsize='small')

########################################################
# Plot singular vectors on the middle surface
########################################################

FourierToX_sin = np.zeros([nu_plot*nv_plot, mnmax_middle])
FourierToX_cos = np.zeros([nu_plot*nv_plot, mnmax_middle])
for imn in range(mnmax_middle):
    FourierToX_sin[:,imn] = np.sin(2*np.pi*(xm_middle[imn]*u_plot_2D_column+xn_middle[imn]*v_plot_2D_column))
    FourierToX_cos[:,imn] = np.cos(2*np.pi*(xm_middle[imn]*u_plot_2D_column+xn_middle[imn]*v_plot_2D_column))

for whichThreshold in range(n_pseudoinverse_thresholds):
    figureNum += 1
    fig = plt.figure(figureNum)
    fig.patch.set_facecolor('white')
    numCols = int(np.ceil(np.sqrt(n_singular_vectors_to_save)))
    numRows = int(np.ceil(n_singular_vectors_to_save*1.0/numCols))

    for whichPlot in range(n_singular_vectors_to_save):
        plt.subplot(numRows,numCols,whichPlot+1)
        data = np.reshape(np.dot(FourierToX_sin, svd_v_transferMatrix_sin[whichThreshold,whichPlot,:]) + \
                          np.dot(FourierToX_cos, svd_v_transferMatrix_cos[whichThreshold,whichPlot,:]), [nu_plot,nv_plot],order='F')
        plt.contourf(v_plot, u_plot, data, numContours)
        #plt.colorbar()
        plt.xlabel('v',fontsize='x-small')
        plt.ylabel('u',fontsize='x-small')
        plt.title('Singular vector v '+str(whichPlot+1)+"\ns="+str(svd_s_transferMatrix[whichThreshold,whichPlot]),fontsize='x-small')

    plt.tight_layout()
    ax = fig.add_axes(np.array([0,0,1,1]), frameon=False)
    ax.text(0.5,0.99,"Efficiency-ordered B_n distributions on the middle surface (threshold="+str(pseudoinverse_thresholds[whichThreshold])+")",horizontalalignment='center',verticalalignment='top',fontsize='small')

########################################################
# Now make 3D surface plot
########################################################

figureNum += 1
fig = plt.figure(figureNum)
fig.patch.set_facecolor('white')
ax = fig.gca(projection='3d')
ax.plot_surface(r_plasma[:,:,0], r_plasma[:,:,1], r_plasma[:,:,2], rstride=1, cstride=1, color='r',linewidth=0)

maxIndex = int(nvl_middle*0.7)
ax.plot_surface(r_middle[:maxIndex,:,0], r_middle[:maxIndex,:,1], r_middle[:maxIndex,:,2], rstride=1, cstride=1, color='m',linewidth=0)

maxIndex = int(nvl_outer*0.55)
minIndex = int(nvl_outer*0.15)
ax.plot_surface(r_outer[minIndex:maxIndex,:,0], r_outer[minIndex:maxIndex,:,1], r_outer[minIndex:maxIndex,:,2], rstride=1, cstride=1, color='b',linewidth=0)

plotLMax = r_outer.max()
ax.auto_scale_xyz([-plotLMax, plotLMax], [-plotLMax, plotLMax], [-plotLMax, plotLMax])





plt.show()

